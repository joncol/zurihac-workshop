<!DOCTYPE html>
<html>
  <head>
    <title>Haskell - Adventures in IO</title>
    <meta charset="utf-8">
    <style>
      /* @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic); */
      @import url(css/metropolis.css);
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, title-slide
count: false

![Haskell - Adventures in IO](img/session2.png)

.less-line-height[
Alejandro Serrano @ ZuriHac 2022

.grey[🐦 @trupill - 🐈‍⬛ serras - 👨‍💻 Tweag]
]

---

# 🥅 Overall goal

### .grey[How do we build software with Haskell?]

1. ~~Domain-specific languages <br /> Representing actions and scripts <br /> Property-based testing~~

2. Communicating over the network <br /> Serialization (without boilerplate) <br /> Error handling <br /> Concurrency across threads

---

# 🃏 Overall goal

### .grey[Build an interactive card game]

1. Represent the cards and the actions
2. Communicate different clients

<table>
  <tr>
    <td style="vertical-align: top"><img src="img/pikachucard.png" width="100%" /></td>
    <td width="82%" style="padding-left: 20px; line-height: 1.3;">
      <h3 style="margin-bottom: -20px"><img src="img/pikachu.png" width="32px" /> Pokémon Trading Card Game</h3>
      <p>Goal: knock out 6 of your opponent's Pokémon using attacks</p>
    </td>
  </tr>
</table>

---

# 🃏 Overall goal

### .grey[Build an interactive card game]

1. Represent the cards and the actions
2. Communicate different clients

<table>
  <tr>
    <td style="vertical-align: top"><img src="img/pikachucard.png" width="100%" /></td>
    <td width="82%" style="padding-left: 20px; line-height: 1.3;">
      <h3><img src="img/pikachu.png" width="32px" /> Pokémon Trading Card Game</h3>
      <h2>Waaaay too complex for 1.5h!</h2>
    </td>
  </tr>
</table>

---

# 🪨 Rock 🧻 Paper ✂️ Scissors

<div style="margin-top: -20px">&nbsp;</div>

<img src="img/rps.png" width="95%" />

---

# 🪨 Rock 🧻 Paper ✂️ Scissors

<div style="margin-top: -20px">☁️ in the cloud</div>

<img src="img/rps.png" width="95%" />

---

# ☁️🪨🧻✂️ Cloudy RPS

☁️ Central server which processes requests

1️⃣ Player #1 joins and gets a code

2️⃣ Player #2 joins the session using that code

🪨🧻✂️ Players play RPS as much as they want
- The server receives the choices and sends the winner to both players

---

# 📚 Our stack

<img src="img/haskell-rainbow.gif" height="40px" /> Haskell (of course)

`network-simple` for networking

`binary` and `aeson` for serialization

`stm` for concurrency

---

# 🎲 Dice roll in the cloud

🔢 Client requests a roll of _n_ faces

☁️ Server returns a random value

<img src="img/random_number.png" width="80%" />

.smaller[.little-margin-top[
_(mandatory XKCD strip)_
]]

---

# 🖧 Server-side `network-simple`

Let's practice signature-reading skills

.code70[
```haskell
serve
  :: MonadIO m
  => HostPreference
  -- ^ Host to bind.
  -> ServiceName
  -- ^ Server service port to bind.
  -> ((Socket, SockAddr) -> IO ())
  -- ^ Computation to run in a different thread
  --   once an incoming connection is accepted.
  -> m a -- ^ This function never returns.
```
]

---

# 🖧 Server-side `network-simple`

`serve` takes care of:

- Listening all the time at the given port
- Whenever a new connection request comes <br/> 1️⃣ accept it, <br /> 2️⃣ **spawn a new thread**, <br /> 3️⃣ run the callback.

---

# ➿ `go` pattern

Once we accept, we go into an (infinite) _loop_

- Usually with a recursive `go` function

.code70[
```haskell
diceServer :: IO ()
diceServer = serve "*" "8080" $ \(skt, _) -> do
  -- initialization
  go skt
  where go :: Socket -> IO () 
        go skt = do
          -- read and parse request
          -- send a response
          go skt  -- and over again!
```
]

---

# 🖧 Server-side `network-simple`

Requests and responses are 64-bit numbers

.little-margin-top[.code70[
```haskell
go :: Socket -> IO ()
go skt = do
  -- read and parse request
  mayBytes <- recv skt 8
  case mayBytes of
    Nothing -> pure ()  -- done
    Just bytes -> do
      let Right max = decode @Word64 bytes
      response <- encode <$> randomRIO (0, max)
      -- send a response
      send skt response
      go skt  -- and over again!
```
]]

---

# 🏁 Recognizing end-of-connection

If `recv` returns nothing, we stop the loop

```haskell
go skt = do
  -- read and parse request
  mayBytes <- recv skt 8
  case mayBytes of
    Nothing -> pure ()  -- done
    Just bytes -> do
      ...
      go skt  -- and over again!
```

---

# 🔄 Serialization

Conversion to and from `ByteString`

- `cereal` for binary encoding
- `aeson` for JSON
- `avro` for Avro (used in Kafka)
- ...

---

# 🔄 Serialization

Users implement instances of some classes

- Just one, like `Serialize` in `cereal`
- Two, like `ToJSON` and `FromJSON`

And then conversion is provided by generic

```haskell
encode :: Serialize a {- or -} ToFormat a
       => a -> ByteString
decode :: Serialize a {- or -} FromFormat a
       => ByteString -> Either Error a
```

---

# 🪢 Type applications

Help the compiler to disambiguate types

```haskell
decode @Word64 bytes
```

Other possibility is `ScopedTypeVariables`

---

# 🎲 Dice roll client

## .grey[🧑‍💻 Time for practice!]

.code70[
```haskell
connect
  :: (MonadIO m, MonadMask m)
  => HostName
  -- ^ Server hostname or IP address.
  -> ServiceName 
  -- ^ Server service port.
  -> ((Socket, SockAddr) -> m r)
  -- ^ Computation taking the communication
  --   socket and the server address.
  -> m r
```
]

---

# 🎲 Dice roll and increment

### .grey[We want to extend the functionality]

How do we (de)serialize command and data?

1. Express them as data types
2. Implement `Serialize` instances

---

# 🎲 Dice roll and increment

### .grey[We want to extend the functionality]

How do we (de)serialize command and data?

1. Express them as data types

```haskell
data Request 
  = DiceRoll  { max    :: Word64 }
  | Increment { number :: Word64 }

type Response = Word64
```

---

# 🎲 Dice roll and increment

### .grey[We want to extend the functionality]

How do we (de)serialize command and data?

1. Express them as data types
2. ~~Implement `Serialize` instances~~

## Use automatic deriving!

---

# 🤖 Automatic deriving

Compiler writes instances for us

- `Eq`, `Show`, and others are built-in
- Extensible with the `Generic` mechanism

.code70[
```haskell
{-# language DeriveGeneric, DeriveAnyClass #-}

data Request 
  = DiceRoll  { max    :: Word64 }
  | Increment { number :: Word64 }
  deriving (Generic, Serialize)
```
]

---

# 💬 Greeting in the cloud

## .grey[🧑‍💻 Time for practice!]

Implement your own greeting service

- Choose whatever requests you want
- (De)serialize using JSON
- Implement the server using the `go` pattern

---

# ‼️ Exceptions

You forget to start the server and...

```
> DiceRoll.diceClient 3
*** Exception: Network.Socket.connect: 
      <socket: 12>: does not exist
      (Connection refused)
```

## 😱 WAAAAAAT????

---

# ‼️ Exceptions

Haskell's `IO` runtime uses **exceptions**

- Network or connection problems
- File (or resource) not found
- and many more input/output problems

Even some built-in features use exceptions

- Pattern match failure
- `undefined` and `error`

---

1. Build a server for dice rolls
2. Learn how to serialize
3. Async server for RPS
   - First connect and get a code
   - The other person gets a code too
4. Handle exceptions and resources
   - Disconnection of the other

---

class: center, middle, title-slide

# 🤩 It's been a pleasure

## Enjoy the rest of ZuriHac!

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>