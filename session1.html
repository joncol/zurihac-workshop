<!DOCTYPE html>
<html>
  <head>
    <title>Haskell - The Legend of DSLs</title>
    <meta charset="utf-8">
    <style>
      /* @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic); */
      @import url(css/metropolis.css);
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, title-slide
count: false

![Haskell - The Legend of DSLs](img/session1.png)

.less-line-height[
Alejandro Serrano @ ZuriHac 2022

.grey[🐦 @trupill - 🐈‍⬛ serras - 👨‍💻 Tweag]
]

---

# 🥅 Overall goal

### .grey[How do we build software with Haskell?]

---

# 🥅 Overall goal

### .grey[How do we build software with Haskell?]

1. Domain-specific languages <br /> Representing state transitions <br /> Property-based testing

2. Communicating over the network <br /> Serialization (without boilerplate) <br /> Resource and error handling

---

# 🃏 Overall goal

### .grey[Build an interactive card game]

1. Represent the cards and the actions
2. Communicate different clients

---

# 🃏 Overall goal

### .grey[Build an interactive card game]

1. Represent the cards and the actions
2. Communicate different clients

<table>
  <tr>
    <td><img src="img/zurihac.svg" width="100%" /></td>
    <td width="70%" style="padding: 10px;"><div class="grey font120">This is <b>ZuriHac</b>!</div> Collaborate <br />Discuss<br />Enjoy</td>
  </tr>
</table>

---

# <img src="img/pikachu.png" width="32px" /> Pokémon Trading Card Game

Players take turns drawing and playing cards

<table>
  <tr>
    <td style="vertical-align: top"><img src="img/pikachucard.png" width="100%" /></td>
    <td width="68%" style="padding-left: 20px; line-height: 1.3;">
      <div style="margin-bottom: -20px">Goal: knock out 6 of your opponent's Pokémon</div>
        <ul>
          <li>For this your use <b>attacks</b></li>
          <li>Those attacks cost <b>energy</b></li>
          <li>Each attack does <b>damage</b></li>
          <li><b>HP</b> define the maximum damage before knock-out</li>
        </ul>
    </td>
  </tr>
</table>

---

# 🏗️ Our approach

### .grey[3 blocks of roughly 20 minutes each]

1. Representing cards
2. Representing actions and state
3. Testing actions

---

# 🏗️ Our approach

### .grey[3 blocks of roughly 20 minutes each]

1. Representing cards
2. Representing actions and state
3. Testing actions

## .grey[Domain-specific Language (DSL)]

Implementation of the _Ubiquitous Language_ idea from DDD, the code speaks the domain

---

# <img src="img/pikachu.png" width="32px" /> Representing cards

&nbsp;

<table>
  <tr>
    <td style="vertical-align: top"><img src="img/pikachucard.png" width="100%" /></td>
    <td width="68%" style="padding-left: 20px; line-height: 1.3;">
      <div style="margin-bottom: -20px">Each card comes with...</div>
        <ul style="margin-bottom: 20px">
          <li>Name: <span class="remark-code-zoom">Pikachu</span></li>
          <li>Type: <img src="img/energy/lightning.webp" height="32px" /></li>
          <li>HP: 70</li>
          <li>Attack(s)</li>
        </ul>
        (forget about the rest for now)
    </td>
  </tr>
</table>

---

# ⚙️ Algebraic Data Types (ADTs)

<table style="font-size: 70%">
  <tr>
    <td style="vertical-align: top; text-align: right;"><img src="img/pikachucard.png" width="60%" /></td>
    <td width="68%" style="padding-left: 20px; line-height: 1.3;">
      <div style="margin-bottom: -20px">Each card comes with...</div>
        <ul style="margin-bottom: 20px">
          <li>Name: <span class="remark-code-zoom">Pikachu</span></li>
          <li>Type: <img src="img/energy/lightning.webp" height="20px" /></li>
          <li>HP: 70</li>
          <li>Attack(s)</li>
        </ul>
    </td>
  </tr>
</table>

Straightforward translation of the description

.code70[
```haskell
data Card = Card { name    :: Text
                 , typ     :: Energy
                 , hp      :: Natural
                 , attacks :: [Attack] }
```
]

---

# ⚙️ Algebraic Data Types (ADTs)

<table style="font-size: 70%">
  <tr>
    <td style="vertical-align: top; text-align: right;"><img src="img/pikachucard.png" width="60%" /></td>
    <td width="68%" style="padding-left: 20px; line-height: 1.3;">
      <div style="margin-bottom: -20px">Each card comes with...</div>
        <ul style="margin-bottom: 20px">
          <li>Name: <span class="remark-code-zoom">Pikachu</span></li>
          <li>Type: <img src="img/energy/lightning.webp" height="20px" /></li>
          <li>HP: 70</li>
          <li>Attack(s)</li>
        </ul>
    </td>
  </tr>
</table>

.code70[
```haskell
data Card = Card { name    :: Text
                 , typ     :: Energy
                 , hp      :: HP
                 , attacks :: [Attack] }

newtype HP = HP Natural 
           deriving (Eq, Show, Num)
```
]

---

# ☯️ Energies

There are 10 types of energy in the game,

- 9 regular energies <img src="img/energy/grass.webp" width="32px" /> <img src="img/energy/fire.png" width="32px" /> <img src="img/energy/water.webp" width="32px" /> <img src="img/energy/lightning.webp" width="32px" /> <img src="img/energy/fighting.webp" width="32px" /> <img src="img/energy/psychic.webp" width="32px" /> <img src="img/energy/darkness.webp" width="32px" /> <img src="img/energy/metal.webp" width="32px" /> <img src="img/energy/dragon.webp" width="32px" />
- Colorless energy <img src="img/energy/colorless.webp" width="32px" />
    - Any card providing a regular energy may also provide colorless energy

<img src="img/attack.png" height="48px" style="margin-top: 10px; margin-bottom: -10px;" /> = 2 <img src="img/energy/lightning.webp" width="32px" /> + 1 of any other

---

# ☯️ Energies

There are 10 types of energy in the game,

- 9 regular energies <img src="img/energy/grass.webp" width="32px" /> <img src="img/energy/fire.png" width="32px" /> <img src="img/energy/water.webp" width="32px" /> <img src="img/energy/lightning.webp" width="32px" /> <img src="img/energy/fighting.webp" width="32px" /> <img src="img/energy/psychic.webp" width="32px" /> <img src="img/energy/darkness.webp" width="32px" /> <img src="img/energy/metal.webp" width="32px" /> <img src="img/energy/dragon.webp" width="32px" />
- Colorless energy <img src="img/energy/colorless.webp" width="32px" />

.code70[
```haskell
data Energy = Colorless
            | Grass | Fire | Water
            | Lightning | Fighting | Psychic
            | Darkness | Metal | Dragon

data Card = PokemonCard { ... }
          | EnergyCard  { typ :: Energy }
```
]

---

# ⚔️ Attacks

We consider only "simple" attacks for now

<div style="text-align: center"><img src="img/attack.png" height="60px" /></div>

.code70[
```haskell
data Attack = Attack { attackName :: Text
                     , cost       :: [Energy] 
                     , damage     :: Natural }
```
]

---

# 🧑‍💻 Time for practice!

Define values for the following cards

<img src="img/grookeycard.png" width="40%" />
<img src="img/goomycard.png" width="40%" />

---

# 🧑‍💻 Time for practice!

Check whether some energy cards are enough to "pay" for the cost of an attack

```haskell
enoughEnergy :: [Energy] -> [Card] -> Bool
```

Then, refine it to return the missing energy

```haskell
missingEnergy :: [Energy] -> [Card]
              -> Maybe [Energy]
```

---

# ⚔️ Attacks, redux

.code70[
```haskell
data Attack = Attack { ..., damage :: Natural }
```
]

## .grey[This is a ~~lie~~ simplification]

---

# ⚔️ Attacks, redux

<img src="img/attack1.png" width="80%" />
<img src="img/attack2.png" width="80%" />
<img src="img/attack3.png" width="80%" />
<img src="img/attack4.png" width="80%" />

---

# ⚔️ Attacks, redux

.code70[
```haskell
data Attack = Attack { ..., damage :: Natural }
```
]

## .grey[This is a ~~lie~~ simplification]

.top-margin[
- More actions than mere damage
    - Draw and discard cards
- Actions may depend on the state
    - Attached cards
    - Coin flips
- Actions may involve conditionals and loops
]

---

# ⚔️ Attacks, redux

.code70[
```haskell
data Attack = Attack { ..., action :: ??? }
```
]

## How do we model .grey[actions]?

.top-margin[
- More actions than mere damage
    - Draw and discard cards
- Actions may depend on the state
    - Attached cards
    - Coin flips
- Actions may involve conditionals and loops
]

---

# 🪙 Coin flips

<img src="img/attack5.png" width="80%" />

.code70[
```haskell
data FlipOutcome = Heads | Tails

data Action
  = FlipCoin (FlipOutcome -> Action)
  | Damage Natural

surpriseAttackAction
  = FlipCoin $ \case Heads -> Damage 30
                     Tails -> Damage 0
```
]

---

# 🪙 Coin flips

<img src="img/attack1.png" width="80%" />

## .grey[🧑‍💻 Time for practice!]

---

# 🪙 Coin flips

<img src="img/attack1.png" width="80%" />

```haskell
ironTailAction = go 0
  where
    go acc = FlipCoin $ \case
      Tails -> Damage acc
      Heads -> go (acc + 30)
```

---

# 🧞 Syntax/algebra and interpretation

`Action` defines the **syntax** of our DSL <br /> (also known as **algebra** in some circles)

> "The language itself", "what we can say"

---

# 🧞 Syntax/algebra and interpretation

`Action` defines the **syntax** of our DSL <br /> (also known as **algebra** in some circles)

An **interpretation** defines how each value behaves in a certain context

> "What a sentence means"

1 syntax / algebra ⟷ ∞ interpretations

---

# 🎰 Randomness interpretation

During the actual game, we expect to generate random coin flips to obtain the actual damage

```haskell
interpretRandom :: Action -> IO Natural
```

## .grey[🧑‍💻 Time for practice!]

---

# 🎰 Randomness interpretation

During the actual game, we expect to generate random coin flips to obtain the actual damage

```haskell
interpretRandom :: Action -> IO Natural
interpretRandom (Damage d)   = pure d
interpretRandom (FlipCoin f) = do
  outcome <- flipCoin
  interpretRandom (f outcome)
  -- one-liner
  -- flipCoin >>= interpretRandom . f
```

---

# 🎴 Actions about cards

<img src="img/attack2.png" width="80%" />
<img src="img/attack3.png" width="80%" />
<img src="img/attack4.png" width="80%" />

---

# 🎴 Actions about cards

.code70[
```haskell
data Action
  = FlipCoin (FlipOutcome -> Action)
  | DrawCard (Maybe Card -> Action)
    -- ^ there may not be more cards
  | QueryAttached ([Card] -> Action)
    -- ^ get info. about the current Pokémon
  | Damage Natural
```
]

### .grey[Can you spot the pattern? 🔍]

---

# 🎴 Actions about cards

.code70[
```haskell
data Action
  = FlipCoin (FlipOutcome -> Action)
  | DrawCard (Maybe Card -> Action)
    -- ^ there may not be more cards
  | QueryAttached ([Card] -> Action)
    -- ^ get info. about the current Pokémon
  | Damage Natural
```
]

- `Damage` is a **final** action
- The rest "generate" a value, <br /> which is consumed to keep going

---

# 🔩 The `Operational` monad

.code70[
```haskell
data Program instr a where
  Done   :: a -> Program instr a
  (:>>=) :: instr a
         -> (a -> Program instr b)
         -> Program instr b
```
]

Split the pattern from the concrete instructions

.code70[
```haskell
data Action a where
  FlipCoin :: Action FlipOutcome
  DrawCard :: Action (Maybe Card)
  QueryAttached :: Action [Card]
```
]

---

# 🪙 Operational coin flips

<img src="img/attack1.png" width="80%" />

```haskell
perform :: instr a -> Program instr a
perform action = action :>>= Done

instance Functor     (Program instr)
instance Applicative (Program instr)
instance Monad       (Program instr)
```

---

# 🪙 Operational coin flips

<img src="img/attack1.png" width="80%" />

```haskell
ironTailAction :: Program Action Natural
ironTailAction = do
  outcome <- perform FlipCoin
  case outcome of
    Tails -> pure 0
    Heads -> (30 +) <$> ironTailAction
```

---

# 🪙 Operational coin flips

<img src="img/attack1.png" width="80%" />

Being a `Monad` gives access to many functions

.code70[
```haskell
ironTailAction :: Program Action Natural
ironTailAction = do
  hs <- unfoldWhileM (== Tails) (perform FlipCoin)
  pure $ 30 * genericLength hs
```
]

`unfoldWhileM` comes from `monad-loops`

---

# 🎴 Actions about cards

<img src="img/attack4.png" width="80%" />

## .grey[🧑‍💻 Time for practice!]

.margin-top[
1. Write a function to **draw *n* ** cards
2. Add an additional operation to **discard** cards
  - Must include a predicate to select cards
  - Outcome: whether a card was discarted
]

---

class: center, middle, title-slide

# 🤩 It's been a pleasure

## Enjoy the rest of ZuriHac! <br /> .grey[See you again on Monday? 🤗]

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>